# Ch 7 Array 陣列
陣列是由相同資料形態所組成的集合。由於陣列在記憶體中是占用[[連續記憶體]]，元素之間索引值以 0 起始逐個遞增，因此在檢索元素方面非常高效；但也因此導致陣列在宣告之初，必須決定其元素數量 ( 陣列大小 )，這樣電腦才能夠根據陣列大小在記憶體中開闢空間儲存元素内容，進而導致陣列一旦被宣告，後續都將無法改變陣列大小。
### 7.0 陣列特點 ( 重點 )
- 陣列占用連續記憶體空間
- 陣列一旦被宣告，陣列大小將無法在後續改變
- 陣列索引值由 0 開始遞增
- 陣列元素形態都是相同的

### 7.1 Array 宣告
以下使用整數型陣列舉例如何宣告陣列
``` c
// Sample 1：直接定義元素内容
int array1[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

// Sample 2：定義陣列大小，元素内容暫且不知
int array2[10];

// Sample 3：同時定義陣列大小與陣列元素
int array3[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
```
從上面的範例不難看出，無論如何都要讓電腦知道陣列的大小。因此在不告知陣列大小的情況下，陣列元素的數量就是該陣列的大小。

### 7.2 Array In RAM 記憶體中的陣列
假設 陣列已經被宣告，參考：( 7.1 Array 宣告 | Sample 3 | array3 )
|Address 記憶體地址| 資料 (元素) | Index 索引值 |
|:---------------:|:----------:|:-----------:|
| 0x00000010      | 1          | 0           |
| 0x00000014      | 2          | 1           |
| 0x00000018      | 3          | 2           |
| 0x00000022      | 4          | 3           |
| 0x00000026      | 5          | 4           |
| 0x00000030      | 6          | 5           |
| 0x00000034      | 7          | 6           |
| 0x00000038      | 8          | 7           |
| 0x00000042      | 9          | 8           |
| 0x00000046      | 10         | 9           |
| 0x00000050      | ???        | Null        |
| 0x00000052      | 占用       | Null        |
| 0x00000056      | 占用       | Null        |

以上記憶體列表展示了陣列在記憶體中的狀況。在説明之前必須要清楚以下幾點：
- 0x00000000 是 16 進位表示法
- int 整數型態占記憶體 32bit = 4Byte = 0x00000004
- 計算陣列在記憶體中所占空間及地址範圍

    --- 
    ### 計算陣列占用空間

    已知陣列宣告時為：
    ```
    - int 整數型態
    - 大小為 10 個元素
    ```
    因此陣列在記憶體中實際占用空間：
    ```
    4 * 10 = 40 Bytes
    ```
    
    --- 
    ### 計算陣列地址範圍

    根據表中記憶體空間起始位址為：
    ```
    0x00000010
    ```
    陣列在記憶體中占用空間的地址範圍：
    ```
    0x00000010 ~ ( 0x00000010 + 0x00000040 ) = 0x00000050
    ```

清楚以上的理論基礎後，我們聚焦至記憶體列表中的資料 ??? 處，這意味著兩點：
- 1. 這個記憶體空間無人使用
- 2. 這個記憶體空間剩餘大小為 2Bytes

### 爲什麽陣列一旦宣告就無法改變大小
記憶體列表中資料欄位有兩個分別被占用的空間，意味著電腦中其他軟體或自己所宣告的變數，被電腦安排保存至此。

電腦也必須在一開始掌握陣列大小後，立刻檢索記憶體中有哪一部分是連續且無人使用的空間可分配給使用者。

因此超出陣列地址範圍的記憶體空間，根本無法確定是否有人在使用，因此無法輕易的使陣列變大；反之使陣列變小相對容易，就是捨棄空間的概念。

這就很好的解釋了爲什麽陣列在宣告之初，必須告知電腦陣列元素數量 ( 陣列大小 )，以及爲什麽陣列宣告後，無法改變大小。

#### 額外知識
陣列的大小并非無法改變，而是這種操作非常危險，且超出陣列的可控範圍。大多數時候我們又會希望節省空間、降低記憶體碎片 ( 即：記憶體列表中資料為 ??? 就是記憶體碎片，意思是空間小到難以被利用 )，這種情況怎麽辦呢？
- 陣列大小調整
    - 參考：Pointer 指標 ( 記憶體 )
    - 參考：Malloc 動態記憶體分配 ( 記憶體 )

- 替代方案
    - 參考：Linked List 資料連結 ( 資料結構 )

### 7.3 使用規則及範例説明

//TODO:
